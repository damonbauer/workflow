<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
  <title>Big</title>
  <link href="big.css" rel="stylesheet" type="text/css" />
  <link href="./themes/light.css" rel="stylesheet" type="text/css" />
  <link href="custom.css" rel="stylesheet" type="text/css" />

  <script>BIG_ASPECT_RATIO=false;</script>
  <script src="big.js"></script>
  <script src="custom.js"></script>
</head>
<body class="light">
  <div>
    work

    <notes>
      INTRO:
      Hi, I'm Damon Bauer. I'm a developer on the Gazelle Debit Card team. I've been at Ramsey Solutions for 5 1/2 years. I started working on daveramsey.com, then moved to EveryDollar where I worked on the browser app for about 3 years.

      This is a talk about how I do work. Most of these ideas are not mine, but I've learned them over my time here.

      There's a good chance you've heard of, or even practice, a lot of what I'm going to talk about. My hope is that everyone can find at least _something_ to try and improve our code, processes and end products.

      One thing you'll probably notice as I speak is that this talk has almost nothing to do with the actual code you write. This talk has much more to do with how you communicate, think about problems, and find solutions that serve your team, the business, and ultimately the users of your code.

      One thing I want to highlight... keep this in mind throughout this talk - a core value of the Front End Chapter is to: "ship value first & early, and talk to our customers"

      ******** FIND A GOOD EXAMPLE OF A FEATURE THAT WE BROKE DOWN ********
    </notes>
  </div>

  <div>
    part 1: plan

    <notes>
      How do we break this work down? 
    </notes>
  </div>

  <div>
    <em>ruthlessly</em> cut scope
    <div class="part-marker">part 1: plan</div>

    <notes>
      * Alongside designers and product managers, ask these questions:
        * what can we agree on that is the smallest piece of work?
        * what can we _not_ ship?
        * what can we get away with _not_ doing?
      * Designers push the boundaries of our UI's. They challenge our assumptions, they question why something is technically not possible. This is a good thing! This is your chance to challege them! It's not a fight or a power struggle; it's an exercise in give and take and learning what's imperative to keep vs. what's a "nice to have".
      * Once you've cut scope, ensure these 3 things are true with that smallest piece of work.
    </notes>
  </div>

  <div>
    provide <em>some</em> user value
    <div class="part-marker">part 1: plan: ruthlessly cut scope</div>

    <notes>
      The most important thing to ensure is that this new piece of work still provides user value.

      If the user can still perform the task they need, you're on the right track. Now it becomes a discussion with the rest of your team to ensure what will be delivered is an acceptable first iteration.
    </notes>
  </div>

  <div>
    <img src="images/cut-scope-mockup.png">
    <img src="images/cut-scope-v1.png">
    <div class="part-marker">part 1: plan: ruthlessly cut scope</div>

    <notes>
      Here are 2 screenshots from a "transfer funds" feature we built. The goal was to enable a user to transfer funds from a connected bank account into their Gazelle account. On the left was the mockup, on the right was what we delivered as a _3rd_ iteration.

      Things we cut included: bank icons, custom select box, account balances & numbers, to/from toggle, scheduling the transfer, withdraw & deposit estimates.

      This was around 4 months ago... and we're still using what's on the right. We'll eventually get to improving it, but we're solving more important problems right now.
    </notes>
  </div>

  <div>
    don't box yourself in
    <div class="part-marker">part 1: plan: ruthlessly cut scope</div>
    <notes>
      The small piece of work should help build a foundation to help you iterate quickly.

      For example, our very first iteration of this feature was a page that had a single button of "Transfer $25". That's it. You could transfer $25 into Gazelle.

      This didn't box us in because we were able to build all the code behind the scenes to accept an account to transfer from, an account to transfer to, and an amount. We were able to both ship _something_ and build the back end functionality we'd need no matter what the interface is.

      That leads me to the last point - ship quickly & learn.
    </notes>
  </div>

  <div>
    learn
    <div class="part-marker">part 1: plan: ruthlessly cut scope</div>
    <notes>
      The point of this exercise is to ship as fast as you can, so you can begin learning how real people interact with your product in real environments.

      This isn't limited to just "did a user like this feature" either.
      For instance... the number of times I've been bitten by a CloudFront configuration not forwarding query parameters, or not accepting cookies... is embarrasing.
      However, if we ship something out to production quickly, we are able to find those things that much faster. In this sort of problem, having shipped small pieces rules out a lot of "potential" problems, so it's easier to find that my cookies aren't being whitelisted.
    </notes>
  </div>

  <div>
    before code
    <div class="part-marker">part 1: plan</div>

    <notes>
      Now that we have an understanding about how we're trying to go about building things, let's talk about actually building it. Before we even write the code, though, we can flex our software "design" muscle. That's what we'll focus on for the next few minutes.
      
      Let me say this from the top: Pull Requests _should be_ the manifestation of all the planning your team has gone through & agreed to _before_ touching code.

      Let's talk about why.
    </notes>
  </div>

  <div>
    early feedback
    <div class="part-marker">part 1: plan: before code</div>

    <notes>
      When we pair or even group up, you're able to use the team as a sounding board to discuss ideas, tradeoffs and work through logic decisions.

      We have a saying here, "If you want to go fast, work alone. If you want to go far, work together." This is never more true than applying it to this idea. When I plan how to solve a problems _together_, I inevitably end up with a better solution. We're able to bounce ideas off one another, think of different edge cases and talk through different patterns.
    </notes>
  </div>

  <div>
    share context
    <div class="part-marker">part 1: plan: before code</div>

    <notes>
      This idea piggybacks off the last. If we're working as a group to solve a problem, we all get context and learn a little more about how our systems work.

      Think of just some of the reasons why you might be out of the office or even away from your desk. Sick time, vacation, DMV, meetings (this one included)... there are plenty of times where a teammate could pick up where you left off. This is why planning the work with your team is crucial. Everyone should have a decent understanding of what we're building and a pretty solidified idea on how.
    </notes>
  </div>

  <div>
    avoid rework
    <div class="part-marker">part 1: plan: before code</div>

    <notes>
      If I make one big PR and I'm the only one with the context of how and why it works, and that PR has some concept baked in that is "wrong", it's very difficult to change, especially if it's all throughout the PR.

      However, in the scenarios I'm proposing, your team has agreed on how to build something and we should all have the context of what we're building. Also, you'll be making very small PRs. These 3 facts make it trivial for a teammate to call out a "wrong" concept early on in the process so it's easier for you to fix it before it is proliferated throughout the code.
    </notes>
  </div>

  <div>
    artifacts

    <notes>
      OK, so we've got an idea of _how_ we want to work, and we know _why_ it's valuable. How do we _actually_ do this?

      The big outcome of this "pre-work" are design artifacts.
    </notes>
  </div>

  <div>
    is/is not
    <div class="part-marker">part 1: plan: artifacts</div>

    <notes>
      One of the clearest, most succinct ways I've found to communicate our intentions as developers is to create an is/is not table.
    </notes>
  </div>

  <div>
    <img src="images/is-isnot-1.png">
    <div class="part-marker">part 1: plan: artifacts: is/is not</div>

    <notes>
      Here's an example. These tables are intended to provide a high level overview about the scope upcoming work.
      
      It helps the author decide what to include - and just as important - what to exclude, by focusing attention by providing distinct boundaries.
    </notes>
  </div>

  <div>
    <img src="images/is-isnot-2.png">
    <div class="part-marker">part 1: plan: artifacts: is/is not</div>

    <notes>
      is/is not tables are meant to be very scannable & consumable. The're not exhaustive or detailed.
    </notes>
  </div>

  <div>
    diagrams
    <div class="part-marker">part 1: plan: artifacts</div>

    <notes>
      In Zach Olsen's training class about documentation, he mentions "favor images over bullets over paragraphs".

      Diagrams are great way to visualize different parts of a system, user flow through a feature, how to trace code through different areas of the codebase and high level application pieces. There are many more uses for diagrams, so explore & try using them.
    </notes>
  </div>

  <div>
    <img src="images/lucidchart-1.png">
    <div class="part-marker">part 1: plan: artifacts: diagrams</div>

    <notes>
      This is a very high level overview of tracing the code & server responses for when a user logs into Gazelle. This is intended for someone who is not actively in the project to know "what happens when a user logs in?"
    </notes>
  </div>

  <div>
    <img src="images/lucidchart-2.png">
    <div class="part-marker">part 1: plan: artifacts: diagrams</div>

    <notes>
      This is a diagram mainly aimed at stakeholders, to describe the "actors" in Gazelle. 
    </notes>
  </div>

  <div>
    <img src="images/lucidchart-3.png">
    <div class="part-marker">part 1: plan: artifacts: diagrams</div>

    <notes>
      Finally, here's a diagram to decide what "name" to display for a transaction. Once you've diagramed the "what", it becomes much easier to write code because it's just an implementation of the logic you've already thought through in the diagram. You're not having to simultaneously figure out "what" you're solving and find an elegant coding pattern to figure out the "how".
    </notes>
  </div>

  <div>
    design docs
    <div class="part-marker">part 1: plan: artifacts</div>

    <notes>
      One of my favorite artifacts to make is what we call a "design document". It's more or less the "master" document that captures all of the other things you & your team has put together.
    </notes>
  </div>

  <div>
    <img src="images/design-doc.png">
    <div class="part-marker">part 1: plan: artifacts: design docs</div>

    <notes>
      I build design documents that aim to explain the "what", combine documentation sources & list proposed subtasks.

      By reading this document, anyone on your team should be able to understand what will be worked on & how you plan to approach implementing it.

      It's also a great reference for yourself as you build the feature. Because the work has already been planned out, now it's just about executing. In my experience, it's much easier to jump back into writing the code after a context switch, lunch, meetings, or the start of a new day because I have all the context of what I'm building right here.
    </notes>
  </div>

  <div>
    part 2: execute
  </div>

  <div>
    deliver <em>something</em>
    <div class="part-marker">part 2: execute</div>
    <notes>
      As I talked about earlier, the whole point of this workflow is aimed at shipping some part of a feature before it's polished or complete.
    </notes>
  </div>

  <div>
    why

    <div class="part-marker">part 2: execute</div>

    <notes>
      Let's talk about why we would do that.
    </notes>
  </div>

  <div>
    low commitment
    <div class="part-marker">part 2: execute: why</div>

    <notes>
      By working like this, we're OK with the fact the code we're writing has a very good chance of being deleted, or at least being re-written almost completely. We need to hold our code with open hands, because at the end of the day what matters is that the code solves a user problem.

      By shipping small pieces of work, we're able to decide whether to keep going on that feature based on user feedback. If our user's tell us that the feature isn't right, we haven't lost weeks/months of work.
    </notes>
  </div>

  <div>
    feedback
    <div class="part-marker">part 2: execute: why</div>

    <notes>
      Again, we get feedback early & often from our users. This can be directly from them in the form of surveys, calls or user tests. Or it can be indirectly, in the form of analytics, engagement or business metrics.
    </notes>
  </div>

  <div>
    metrics
    <div class="part-marker">part 2: execute: why</div>

    <notes>
      One unexpected benefit of working like this that we found on the Gazelle team is that our product manager is able to predict our work rate more accurately. She can then take information to stakeholders and our business can make an informed decision on what to build next.
    </notes>
  </div>

  <div>
    how 
    
    <div class="part-marker">part 2: execute</div>

    <notes>
      Now I want to talk _practically_ about how we can work like this and be successful.
    </notes>
  </div>

  <div>
    tickets as user value
    
    <div class="part-marker">part 2: execute: how</div>

    <notes>
      This idea will probably sound foreign to you. It will probably also sound like a terrible idea. But trust me, it works.

      First: Jira tickets don't exist just for you as a developer. Instead, they exist for stakeholders to know _what_ we're working on. They should be written so that as they move across the board, user value is being delivered and everyone knows what that value is.

      On Gazelle, we make a parent ticket that describes the feature that has all the acceptance criteria, testing notes & user stories. Then, we make _sub tasks_ that we'll use to track our work. So the parent ticket acts almost as an "epic".

      It's common for a ticket to have 10-15, sometimes 20, subtasks if it's a brand new feature.
    </notes>
  </div>

  <div class="layout" style="grid-template-columns: 50% 50%;">
    <img src="images/subtasks-1.png">
    <img src="images/subtasks-2.png">
    <div class="part-marker">part 2: execute: how</div>

    <notes>
      Towards the end of last year, Brendan introduced this idea of "concurrency". Working like this _forces_ concurrency. It enables us to say "we know we need an API, so what should it return?"

      We can agree on the API response, and start building a UI with dummy data that we know we'll get back from the API. At the same time, the API can be built & be hardcoded to return dummy data. While that dummy data is being returned, the we can build code to call that API and get that same dummy data back that we first built the UI with. Then, once the API is functional, it's a simple "verification" that our UI is still working as expected.
    </notes>
  </div>

  <div>
    small PRs
    
    <div class="part-marker">part 2: execute: how</div>

    <notes>
      The other component to breaking the work down to lots of subtasks is making small PRs. I aim for around 300 lines of code changed. Any more than that, I start to question if there's too much happening.

      This is very important: 1 Jira ticket does not mean 1 PR. You can have multiple PRs against a ticket. In fact, it probably means you're breaking the work down well & focusing on one thing.
    </notes>
  </div>

  <div>
    small PRs - why?
    
    <div class="part-marker">part 2: execute: how: small PRs</div>
  </div>

  <div>
    faster & more thorough reviews
    
    <div class="part-marker">part 2: execute: how: small PRs - why?</div>

    <notes>
      When we have small, focused PRs, we are able to receive a review faster and the review is able to be more intentional with their feedback since there should only be a small handful of concepts.
    </notes>
  </div>

  <div>
    easier to understand
    
    <div class="part-marker">part 2: execute: how: small PRs - why?</div>

    <notes>
      As a reviewer, a small, focused PR helps you understand both the changes in the PR AND how the changes fit into the larger system.
    </notes>
  </div>

  <div>
    easier to course correct
    
    <div class="part-marker">part 2: execute: how: small PRs - why?</div>

    <notes>
      This goes hand in hand with what I talked earlier about avoiding rework.

      A small PR makes it easy to find and call out a bad concept early on in the process so it's easier for you to fix it before it is proliferated throughout the code.
    </notes>
  </div>

  <div>
    fewer bugs, merge conflicts

    <div class="part-marker">part 2: execute: how: small PRs - why?</div>

    <notes>
      If we are focusing on building a PR with a narrow focus, and the reviewer has that narrow focus to review, it makes the likelhood of finding a bug much higher, leading to more a more bug-free codebase.

      Small PRs also help reduce merge conflicts because the number of files changed in a PR is likely lower and the changes are more contained. 
    </notes>
  </div>

  <div>
    code is shareable faster

    <div class="part-marker">part 2: execute: how: small PRs - why?</div>

    <notes>
      If your team is dividing and conquering your subtask list, there's a good chance a piece of work needs done first so another one can be worked on. Shipping a small PR means that a dependent piece of code is available quicker, enabling that concurrent work to happen.
    </notes>
  </div>

  <div>
    small PRs -  how?
    
    <div class="part-marker">part 2: execute: how: small PRs</div>

    <notes>
      Of course, we want to author & merge these PRs quickly, so we can't block the runway while the rest of the feature is built. Let's talk about a few ways we can continually ship these small PRs.
    </notes>
  </div>

  <div>
    hidden URL
    
    <div class="part-marker">part 2: execute: how: small PRs - how?</div>

    <notes>
      You could add a new, hidden URL to your project and develop the feature there. As long as it's never linked there, you should be good.
    </notes>
  </div>

  <div>
    hidden UI
    
    <div class="part-marker">part 2: execute: how: small PRs - how?</div>

    <notes>
      This could be a hidden div, if it's just a visual change. Or, to initiate a new feature, you could put it behind a certain button click, or a gesture like a triple click on an element.
    </notes>
  </div>

  <div>
    feature flags
    
    <div class="part-marker">part 2: execute: how: small PRs - how?</div>

    <notes>
      Wrapping code at the highest level in a feature flag is a great way to hide it until it's "turned on". You could use something like Optimzely Rollouts, or something custom. Jason York is a good resource to talk about what's available around the company for feature flags.

      Something we do in Gazelle is wrap some code in a conditional, like "if there is a `flag` query parameter with value of "foo", we can visit a page with that query param and that wrapped code will become visible.
    </notes>
  </div>

  <div>
    <ul>
      <li>
        plan
        <ul>
          <li><em>ruthlessly</em> cut scope</li>
          <li>leave artifacts</li>      
        </ul>
      </li>
      <li>
        execute
        <ul>
          <li>tickets as user value</li>
          <li>small PRs</li>
        </ul>
      </li>
    </ul>
  </div>
  
  <!-- <div>
    commit messages
    
    <div class="part-marker">part 2: execute: how</div>

    <notes></notes>
  </div>

  <div>
    more detail is better
    
    <div class="part-marker">part 2: execute: how: commit messages</div>

    <notes></notes>
  </div> -->
</body>
</html>
